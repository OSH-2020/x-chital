# Q&A

- 你们对于 zCore 的系统调用是如何实现的？是直接使用 zCore 的系统调用？还是说自己编写的系统调用？

    其实 zCore 的系统调用是没法直接拿过来使用的，主要是在于内核中无法直接读取用户空间的指针，因此我们实现了一个类似指针的数据结构，然后替换 zCore 中的指针就可以了。其他的方面我们其实没有太多的修改。

- 内核中的 debug 比较困难，你们是如何在内核中进行 debug 的呢？

    Rust 提供一个 log 的包，我们只需要实现一个 logger 就可以输出比较好的日志，可以显示这一次 log发生在那个文件那个位置，整个 debug 流程还是比较友好的。

- zCore 的 mmap 将文件和内存地址映射，这个过程中会不会有性能损耗？

    不会的，我们使用的是 tmpfs，tmpfs 会在内存中建立一个临时文件系统，不需要进行磁盘同步。

- 你们如何在内核中使用系统调用？

    我们完成系统调用劫持之后，就可以得到每个系统调用的函数的指针，这些这些系统调用是可以直接使用，会得到与在用户态中相同的结果。

- 实现内核和用户的交互的时候，为什么不像 cgroup 那样新建一个文件系统呢？

    其实建立一个文件系统做交互也可以，但是我们不需要做太多的配置，其实一个简单的 ioctl 就已经足够了，没必要使用太过复杂的文件系统来做交互。

- 描述一下进程开始运行的过程？

    首先容器的相应进程会调用 ioctl 来执行容器内的文件，然后 zCore 内部实现了读取 elf 文件，这个执行 ioctl 的进程的虚拟地址会被 zCore 调用 mmap 替换，最后我们会修改系统调用的上下文，修改x64 的 rip、rsp 等寄存器，然后回到用户进程执行时，就可以执行容器内的程序了。具体细节大家可以参考我们主页上的 Notion 文档。